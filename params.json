{"name":"SBV","tagline":"SMT Based Verification in Haskell. Express properties about Haskell programs  and automatically prove them using SMT solvers. Automatically generate straight-line C programs from symbolic Haskell functions.","google":"","body":"SBV: SMT Based Verification in Haskell\r\n======================================\r\n\r\nExpress properties about Haskell programs and automatically prove them using SMT solvers.\r\n\r\n```haskell\r\n$ ghci -XScopedTypeVariables\r\nghci> :m Data.SBV\r\nghci> prove $ \\(x::SWord8) -> x `shiftL` 2 .== 4*x\r\nQ.E.D.\r\nghci> prove $ forAll [\"x\"] $ \\(x::SWord8) -> x `shiftL` 2 .== x\r\nFalsifiable. Counter-example:\r\nx = 128 :: SWord8\r\n```\r\n\r\nThe function `prove` has the following type:\r\n    \r\n```haskell\r\nprove :: Provable a => a -> IO ThmResult\r\n```\r\n\r\nThe class `Provable` comes with instances for n-ary predicates, for arbitrary n.\r\nThe predicates are just regular Haskell functions over symbolic values. Functions for checking satisfiability (`sat` and `allSat`) are also provided.\r\nIn addition, functions using the SBV library can be compiled to C automatically.\r\n\r\nThe hackage site\r\n[http://hackage.haskell.org/package/sbv](http://hackage.haskell.org/package/sbv) is the best place\r\nfor detailed info on the API and browsing the example use cases.\r\n\r\n## Build Status\r\n[![Build Status](https://secure.travis-ci.org/LeventErkok/sbv.png?branch=master)](http://travis-ci.org/LeventErkok/sbv)\r\n\r\nOverview\r\n========\r\nThe Haskell SBV library provides support for dealing with symbolic values\r\nin Haskell. It introduces the types:\r\n\r\n  - `SBool`: Symbolic Booleans (bits).\r\n  - `SWord8`, `SWord16`, `SWord32`, `SWord64`: Symbolic Words (unsigned).\r\n  - `SInt8`,  `SInt16`,  `SInt32`,  `SInt64`: Symbolic Ints (signed).\r\n  - `SInteger`: Symbolic unbounded integers (signed).\r\n  - `SReal`: Symbolic infinite precision algebraic reals (signed).\r\n  - Arrays of symbolic values.\r\n  - Symbolic polynomials over GF(2^n ), polynomial arithmetic, and CRCs.\r\n  - Uninterpreted constants and functions over symbolic values, with user defined axioms.\r\n  - Uninterpreted sorts, and proofs over such sorts, potentially with axioms.\r\n\r\nThe user can construct ordinary Haskell programs using these types, which behave like ordinary Haskell values when used concretely. However, when used with symbolic arguments, functions built out of these types can also be:\r\n\r\n  - proven correct via an external SMT solver (the `prove` function)\r\n  - checked for satisfiability (the `sat`, and `allSat` functions)\r\n  - used in synthesis (the `sat` function with existentials)\r\n  - optimized with respect to cost functions (the `optimize`, `maximize`, and `minimize` functions)\r\n  - quick-checked\r\n  - used in concrete test case generation (the `genTest` function), rendered as values in various\r\n    languages, including Haskell and C.\r\n\r\nIf a predicate is not valid, `prove` will return a counterexample: An \r\nassignment to inputs such that the predicate fails. The `sat` function will\r\nreturn a satisfying assignment, if there is one. The `allSat` function returns\r\nall satisfying assignments, lazily.\r\n\r\nThe SBV library can also compile Haskell functions that manipulate symbolic\r\nvalues directly to C, rendering them as straight-line C programs.\r\n\r\nUse of SMT solvers\r\n==================\r\nThe SBV library uses third-party SMT solvers via the standard SMT-Lib interface\r\n[http://goedel.cs.uiowa.edu/smtlib/](http://goedel.cs.uiowa.edu/smtlib/).\r\n\r\nCurrently, we fully support the following SMT solvers:\r\n\r\n  - [Z3](http://z3.codeplex.com/) from Microsoft,\r\n  - [Yices](http://yices.csl.sri.com) from SRI,\r\n  - [CVC4](http://cvc4.cs.nyu.edu) from New York University and the University of Iowa.\r\n  \r\nOther SMT solvers can be used with SBV as well, with a relatively easy hook-up mechanism. Please\r\ndo get in touch if you plan to use SBV with any other solver.\r\n\r\nPicking a solver\r\n================\r\nIn most cases, you should simply `import Data.SBV` to use the SBV library. This will invoke the default SMT solver\r\nfor queries, which is currently set to Microsoft's Z3. If you want to use any other solver, simply\r\nuse the functions `proveWith`/`satWith` etc., passing `yices`, `cvc4` etc., as the first argument.\r\n\r\nAlternatively, you can import one of the bridge modules, in which case calls to `prove`/`sat` etc. will refer to the corresponding solver:\r\n\r\n  - `import Data.SBV.Bridge.CVC4`<br>\r\n     Uses CVC4 as the underlying SMT solver.\r\n  - `import Data.SBV.Bridge.Yices`<br>\r\n     Uses Yices as the underlying SMT solver.\r\n  - `import Data.SBV.Bridge.Z3`<br>\r\n     Uses Z3 as the underlying SMT solver.\r\n  - `import Data.SBV`<br>\r\n     Uses the default SMT solver, which is currently configured to be Z3.\r\n\r\nNote that you should only import one of the above interfaces at any given time. (If you need to access\r\nmore than one solver in any given module scope, use qualified imports.)\r\n\r\nInstallation\r\n============\r\nThe SBV library is cabalized, so installation should merely be a matter of running \r\n     \r\n     cabal install sbv\r\n\t \r\nPlease see [INSTALL](http://github.com/LeventErkok/sbv/tree/master/INSTALL) for further details.\r\n\r\nCopyright, License\r\n==================\r\nThe SBV library is distributed with the BSD3 license. See [COPYRIGHT](http://github.com/LeventErkok/sbv/tree/master/COPYRIGHT) for\r\ndetails. The [LICENSE](http://github.com/LeventErkok/sbv/tree/master/LICENSE) file contains\r\nthe [BSD3](http://en.wikipedia.org/wiki/BSD_licenses) verbiage.\r\n\r\nThanks\r\n======\r\nThe following people reported bugs, provided comments/feedback, or contributed to the development of SBV in various ways: Ian Blumenfeld, Ian Calvert, Iavor Diatchki, John Erickson, Tom Hawkins, Lee Pike, Austin Seipp, Don Stewart, Josef Svenningsson, and Nis Wegmann.","note":"Don't delete this file! It's used internally to help with page regeneration."}