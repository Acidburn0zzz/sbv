{"name":"SBV","tagline":"SMT Based Verification in Haskell. Express properties about Haskell programs  and automatically prove them using SMT solvers.","body":"SBV: SMT Based Verification in Haskell\r\n======================================\r\n\r\nExpress properties about Haskell programs and automatically prove them using SMT solvers.\r\n\r\n```haskell\r\n$ ghci -XScopedTypeVariables\r\nghci> :m Data.SBV\r\nghci> prove $ \\(x::SWord8) -> x `shiftL` 2 .== 4*x\r\nQ.E.D.\r\nghci> prove $ forAll [\"x\"] $ \\(x::SWord8) -> x `shiftL` 2 .== x\r\nFalsifiable. Counter-example:\r\nx = 128 :: SWord8\r\n```\r\n\r\nThe function `prove` establishes theorem-hood, while `sat` finds any satisfying model. All satisfying models can be lazily computed using `allSat`.\r\n\r\nOverview\r\n========\r\n\r\n  - Explore SBV on [Hackage](http://hackage.haskell.org/package/sbv)\r\n  - [Release Notes](http://github.com/LeventErkok/sbv/tree/master/Changes.md). \r\n  - [![Build Status](https://secure.travis-ci.org/LeventErkok/sbv.png?branch=master)](http://travis-ci.org/LeventErkok/sbv)\r\n\r\nSBV library provides support for dealing with symbolic values in Haskell. It introduces the types:\r\n\r\n  - `SBool`: Symbolic Booleans (bits).\r\n  - `SWord8`, `SWord16`, `SWord32`, `SWord64`: Symbolic Words (unsigned).\r\n  - `SInt8`,  `SInt16`,  `SInt32`,  `SInt64`: Symbolic Ints (signed).\r\n  - `SInteger`: Symbolic unbounded integers (signed).\r\n  - `SReal`: Symbolic infinite precision algebraic reals (signed).\r\n  - Arrays of symbolic values.\r\n  - Symbolic polynomials over GF(2^n ), polynomial arithmetic, and CRCs.\r\n  - Uninterpreted constants and functions over symbolic values, with user defined axioms.\r\n  - Uninterpreted sorts, and proofs over such sorts, potentially with axioms.\r\n\r\nThe user can construct ordinary Haskell programs using these types, which behave like ordinary Haskell values when used concretely. However, when used with symbolic arguments, functions built out of these types can also be:\r\n\r\n  - proven correct via an external SMT solver (the `prove` function),\r\n  - checked for satisfiability (the `sat`, and `allSat` functions),\r\n  - used in synthesis (the `sat` function with existentials),\r\n  - optimized with respect to cost functions (the `optimize`, `maximize`, and `minimize` functions),\r\n  - quick-checked,\r\n  - used for generating Haskell and C test vectors (the `genTest` function),\r\n  - compiled down to C, rendered as straight-line programs or libraries (`compileToC` and `compileToCLib` functions).\r\n\r\n\r\nUse of SMT solvers\r\n==================\r\nThe SBV library uses third-party SMT solvers via the standard [SMT-Lib interface](http://goedel.cs.uiowa.edu/smtlib/). Currently, the following SMT solvers are fully supported:\r\n\r\n  - [Z3](http://z3.codeplex.com/) from Microsoft,\r\n  - [Yices](http://yices.csl.sri.com) from SRI,\r\n  - [CVC4](http://cvc4.cs.nyu.edu) from New York University and the University of Iowa.\r\n  \r\nOther SMT solvers can be used with SBV as well, with a relatively easy hook-up mechanism. Please\r\ndo get in touch if you plan to use SBV with any other solver.\r\n\r\n### Picking a solver\r\nIn most cases, you should simply `import Data.SBV` to use the SBV library. This will invoke the default SMT solver\r\nfor queries, which is currently set to Microsoft's Z3. If you want to use any other solver, simply\r\nuse the functions `proveWith`/`satWith` etc., passing `yices`, `cvc4` etc., as the first argument.\r\n\r\nAlternatively, you can import one of the bridge modules, in which case calls to `prove`/`sat` etc. will refer to the corresponding solver:\r\n\r\n  - `import Data.SBV.Bridge.CVC4`<br>\r\n     Uses CVC4 as the underlying SMT solver.\r\n  - `import Data.SBV.Bridge.Yices`<br>\r\n     Uses Yices as the underlying SMT solver.\r\n  - `import Data.SBV.Bridge.Z3`<br>\r\n     Uses Z3 as the underlying SMT solver.\r\n  - `import Data.SBV`<br>\r\n     Uses the default SMT solver, which is currently configured to be Z3.\r\n\r\nNote that you should only import one of the above interfaces at any given time. (If you need to access\r\nmore than one solver in any given module scope, use qualified imports.)\r\n\r\n### Installation\r\nThe SBV library is cabalized, so installation should merely be a matter of running \r\n     \r\n     cabal install sbv\r\n\t \r\nPlease see [INSTALL](http://github.com/LeventErkok/sbv/tree/master/INSTALL) for further details.\r\n\r\n### Copyright, License\r\nThe SBV library is distributed with the BSD3 license. See [COPYRIGHT](http://github.com/LeventErkok/sbv/tree/master/COPYRIGHT) for\r\ndetails. The [LICENSE](http://github.com/LeventErkok/sbv/tree/master/LICENSE) file contains\r\nthe [BSD3](http://en.wikipedia.org/wiki/BSD_licenses) verbiage.\r\n\r\nThanks\r\n======\r\nThe following people reported bugs, provided comments/feedback, or contributed to the development of SBV in various ways: Ian Blumenfeld, Ian Calvert, Iavor Diatchki, John Erickson, Tom Hawkins, Lee Pike, Austin Seipp, Don Stewart, Josef Svenningsson, and Nis Wegmann.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}