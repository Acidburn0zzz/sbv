{
  "name": "SBV",
  "tagline": "SMT Based Verification in Haskell. Express properties about Haskell programs  and automatically prove them using SMT solvers.",
  "body": "SBV: SMT Based Verification in Haskell\r\n======================================\r\n\r\nExpress properties about Haskell programs and automatically prove them using SMT solvers.\r\n\r\n```haskell\r\n$ ghci\r\nghci> :m Data.SBV\r\nghci> prove $ \\x -> x `shiftL` 2 .== 4 * (x::SWord8)\r\nQ.E.D.\r\nghci> prove $ \\x -> x `shiftL` 2 .== 2 * (x::SWord8)\r\nFalsifiable. Counter-example:\r\n  s0 = 32 :: Word8\r\n```\r\n\r\nThe function `prove` establishes theorem-hood, while `sat` finds any satisfying model. All satisfying models can be lazily computed using `allSat`. SBV can also perform static assertion checks, such as absence of division-by-0, and other user given properties.\r\n\r\nOverview\r\n========\r\n\r\n  - [![Hackage version](http://img.shields.io/hackage/v/sbv.svg?label=Hackage)](http://hackage.haskell.org/package/sbv) (Released: Jan 15th, 2016.)\r\n  - [Release Notes](http://github.com/LeventErkok/sbv/tree/master/CHANGES.md). \r\n\r\nSBV library provides support for dealing with symbolic values in Haskell. It introduces the types:\r\n\r\n  - `SBool`: Symbolic Booleans (bits).\r\n  - `SWord8`, `SWord16`, `SWord32`, `SWord64`: Symbolic Words (unsigned).\r\n  - `SInt8`,  `SInt16`,  `SInt32`,  `SInt64`: Symbolic Ints (signed).\r\n  - `SInteger`: Symbolic unbounded integers (signed).\r\n  - `SReal`: Symbolic infinite precision algebraic reals (signed).\r\n  - `SFloat`: IEEE-754 single precision floating point number. (`Float`.)\r\n  - `SDouble`: IEEE-754 double precision floating point number. (`Double.`)\r\n  - Arrays of symbolic values.\r\n  - Symbolic enumerations, for arbitrary user-defined enumerated types.\r\n  - Symbolic polynomials over GF(2^n ), polynomial arithmetic, and CRCs.\r\n  - Uninterpreted constants and functions over symbolic values, with user defined axioms.\r\n  - Uninterpreted sorts, and proofs over such sorts, potentially with axioms.\r\n  - Ability for users to define their own symbolic types, such as `SWord4`/`SInt4` as needed. (In a future version of SBV, we plan to support these automatically.)\r\n\r\nThe user can construct ordinary Haskell programs using these types, which behave like ordinary Haskell values when used concretely. However, when used with symbolic arguments, functions built out of these types can also be:\r\n\r\n  - proven correct via an external SMT solver (the `prove` function),\r\n  - checked for satisfiability (the `sat`, and `allSat` functions),\r\n  - checked for assertion violations (the `safe` function with `sAssert` calls),\r\n  - used in synthesis (the `sat` function with existentials),\r\n  - optimized with respect to cost functions (the `optimize`, `maximize`, and `minimize` functions),\r\n  - quick-checked,\r\n  - used for generating Haskell and C test vectors (the `genTest` function),\r\n  - compiled down to C, rendered as straight-line programs or libraries (`compileToC` and `compileToCLib` functions).\r\n\r\n\r\nPicking the SMT solver to use\r\n=============================\r\nThe SBV library uses third-party SMT solvers via the standard [SMT-Lib interface](http://smtlib.cs.uiowa.edu/). Use the following `import` statements to pick the corresponding solver:\r\n\r\n  - `import Data.SBV.Bridge.ABC`<br>\r\n     Uses [ABC](http://www.eecs.berkeley.edu/~alanmi/abc/) from University of Berkeley\r\n  - `import Data.SBV.Bridge.Boolector`<br>\r\n     Uses [Boolector](http://fmv.jku.at/boolector/) from Johannes Kepler University\r\n  - `import Data.SBV.Bridge.CVC4`<br>\r\n     Uses [CVC4](http://cvc4.cs.nyu.edu) from New York University and the University of Iowa\r\n  - `import Data.SBV.Bridge.MathSAT`<br>\r\n     Uses [MathSAT](http://mathsat.fbk.eu/) from FBK and DISI-University of Trento\r\n  - `import Data.SBV.Bridge.Yices`<br>\r\n     Uses [Yices](http://yices.csl.sri.com) from SRI\r\n  - `import Data.SBV.Bridge.Z3`<br>\r\n     Uses [Z3](http://github.com/Z3Prover/z3/wiki) from Microsoft\r\n \r\nIf you simply `import Data.SBV`, then the solver defaults to Microsoft's Z3.\r\n\r\nSee [versions](http://github.com/LeventErkok/sbv/blob/master/SMTSolverVersions.md) for a listing of the versions of these tools SBV has been tested with. Please report if you see any discrepancies!\r\n\r\nOther SMT solvers can be used with SBV as well, with a relatively easy hook-up mechanism. Please\r\ndo get in touch if you plan to use SBV with any other solver.\r\n\r\nUsing multiple solvers, simultaneously\r\n======================================\r\nSBV also allows for running multiple solvers at the same time, either picking the result of the first to complete, or getting results from all. See `proveWithAny`/`proveWithAll` and `satWithAny`/`satWithAll` functions. The function `sbvAvailableSolvers` can be used to query the available solvers at run-time.\r\n\r\n### Copyright, License\r\nThe SBV library is distributed with the BSD3 license. See [COPYRIGHT](http://github.com/LeventErkok/sbv/tree/master/COPYRIGHT) for\r\ndetails. The [LICENSE](http://github.com/LeventErkok/sbv/tree/master/LICENSE) file contains\r\nthe [BSD3](http://en.wikipedia.org/wiki/BSD_licenses) verbiage.\r\n\r\nThanks\r\n======\r\nThe following people reported bugs, provided comments/feedback, or contributed to the development of SBV in various ways: Reid Barton, Ian Blumenfeld, Ian Calvert, Christian Conkle, Iavor Diatchki, Thomas DuBuisson, Trevor Elliott, John Erickson, Adam Foltzer, Tom Hawkins, Brian Huffman, Georges-Axel Jaloyan, Tom Sydney Kerckhove, Brett Letner, Philipp Meyer, Lee Pike, Eric Seidel, Austin Seipp, Andrés Sicard-Ramírez, Don Stewart, Josef Svenningsson, Daniel Wagner, Sean Weaver, and Nis Wegmann.",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}