SBV: SMT Based Verification in Haskell
======================================

Express properties about Haskell programs and automatically prove them using SMT solvers.

```haskell
        $ ghci -XScopedTypeVariables
        Prelude> :m Data.SBV
        Prelude Data.SBV> prove $ \(x::SWord8) -> x `shiftL` 2 .== 4*x
        Q.E.D.
        Prelude Data.SBV> prove $ forAll ["x"] $ \(x::SWord8) -> x `shiftL` 2 .== x
        Falsifiable. Counter-example:
          x = 128 :: SWord8
```

The function `prove` has the following type:
    
```haskell
        prove :: Provable a => a -> IO ThmResult
```

The class `Provable` comes with instances for n-ary predicates, for arbitrary n.
The predicates are just regular Haskell functions over symbolic signed and unsigned
bit-vectors. Functions for checking satisfiability (`sat` and `allSat`) are also provided.
In addition, functions using the SBV library can be compiled to C automatically.

Build Status
============
SBV uses Travis-CI's automated build infrastructure, making a build for each commit. Current build status:
[![Build Status](https://secure.travis-ci.org/LeventErkok/sbv.png?branch=master)](http://travis-ci.org/LeventErkok/sbv)

Resources
=========
The SBV library is hosted at [http://github.com/LeventErkok/sbv](http://github.com/LeventErkok/sbv).

The hackage site
[http://hackage.haskell.org/package/sbv](http://hackage.haskell.org/package/sbv) is the best place
for details on the API and the example use cases.

Comments, bug reports, and patches are always welcome.

Overview
========
The Haskell SBV library provides support for dealing with Symbolic Bit Vectors
in Haskell. It introduces the types:

  - `SBool`: Symbolic Booleans (bits).
  - `SWord8`, `SWord16`, `SWord32`, `SWord64`: Symbolic Words (unsigned).
  - `SInt8`,  `SInt16`,  `SInt32`,  `SInt64`: Symbolic Ints (signed).
  - `SInteger`: Symbolic unbounded integers (signed).
  - `SReal`: Symbolic infinite precision algebraic reals (signed).
  - Arrays of symbolic values.
  - Symbolic polynomials over GF(2^n ), polynomial arithmetic, and CRCs.
  - Uninterpreted constants and functions over symbolic values, with user defined axioms.
  - Uninterpreted sorts, and proofs over such sorts, potentially with axioms.

The user can construct ordinary Haskell programs using these types, which behave
very similar to their concrete counterparts. In particular these types belong to the
standard classes `Num`, `Bits`, (custom versions of) `Eq` and `Ord`, along with several
other custom classes for simplifying bit-precise programming with symbolic values. The
framework takes full advantage of Haskell's type inference to avoid many common mistakes.

Furthermore, functions built out of these types can also be:

  - proven correct via an external SMT solver (the `prove` function)
  - checked for satisfiability (the `sat`, and `allSat` functions)
  - used in synthesis (the `sat` function with existentials)
  - optimized with respect to cost functions (the `optimize`, `maximize`, and `minimize` functions)
  - quick-checked
  - used in concrete test case generation (the `genTest` function), rendered as values in various
    languages, including Haskell and C.

If a predicate is not valid, `prove` will return a counterexample: An 
assignment to inputs such that the predicate fails. The `sat` function will
return a satisfying assignment, if there is one. The `allSat` function returns
all satisfying assignments, lazily.

The SBV library can also compile Haskell functions that manipulate symbolic
values directly to C, rendering them as straight-line C programs.

Use of SMT solvers
==================
The SBV library uses third-party SMT solvers via the standard SMT-Lib interface
[http://goedel.cs.uiowa.edu/smtlib/](http://goedel.cs.uiowa.edu/smtlib/).

Currently, we fully support the following SMT solvers:

  - [Z3](http://z3.codeplex.com/) from Microsoft,
  - [Yices](http://yices.csl.sri.com) from SRI,
  - [CVC4](http://cvc4.cs.nyu.edu) from New York University and the University of Iowa.
  
Other SMT solvers can be used with SBV as well, with a relatively easy hook-up mechanism. Please
do get in touch if you plan to use SBV with any other solver.

Prerequisites
=============
You **should** have at least one of the SMT solvers listed above installed on your machine.
Note that z3 is the default solver used by SBV. Other solvers can be used by calling `With` variants
of functions (i.e., `satWith`, `proveWith`, etc.) by providing the appropriate SMT solver name. (For
instance, use `proveWith cvc4`.)

Make sure the executables for the solvers are in your path, so SBV can invoke the solvers
automatically. In cases where you need to install the solvers in alternate places, you can use the
environment variables `SBV_Z3`, `SBV_YICES`, and `SBV_CVC4` to specify the executable locations respectively. Similarly,
any options you'd like to pass to these solvers can be specified in the environment variables `SBV_Z3_OPTIONS`,
`SBV_YICES_OPTIONS`, and `SBV_CVC4_OPTIONS`, although the defaults SBV uses should suffice unless you have specific needs.

Picking a solver
================
In most cases, you should simply `import Data.SBV` to use the SBV library. This will invoke the default SMT solver
for queries, which is currently set to Microsoft's Z3 SMT solver. If you want to use any other solver, simply
use the functions `proveWith`/`satWith` etc., passing `yices`, `cvc4` etc., as the first argument.

Alternatively, you can import one of the bridge modules, so you can use a specific solver without explicitly naming it:

  - `import Data.SBV.Bridge.CVC4`

     Uses CVC4 as the underlying SMT solver.
  - `import Data.SBV.Bridge.Yices`

     Uses Yices as the underlying SMT solver.
  - `import Data.SBV.Bridge.Z3`

     Uses Z3 as the underlying SMT solver.
  - `import Data.SBV`

     Uses the default SMT solver, which is currently configured to be Z3.

Note that you should only import one of the above interfaces at any given time. (If you need to access
more than one solver in any given module scope, use qualified imports.)

Examples
=========
Please see the files under the
[Examples](http://github.com/LeventErkok/sbv/tree/master/Data/SBV/Examples)
directory for a number of interesting applications and use cases. Amongst others,
it contains solvers for Sudoku and N-Queens puzzles as mandatory SMT solver examples in
the Puzzles directory.

Installation
============
The SBV library is cabalized. Assuming you have cabal/ghc installed, it should merely
be a matter of running 
     
         cabal install sbv
	 
Please see [INSTALL](http://github.com/LeventErkok/sbv/tree/master/INSTALL) for installation details.

Once the installation is done, you can run the executable `SBVUnitTests` which will
execute the regression test suite for SBV on your machine to ensure all is well.

Copyright, License
==================
The SBV library is distributed with the BSD3 license. See [COPYRIGHT](http://github.com/LeventErkok/sbv/tree/master/COPYRIGHT) for
details. The [LICENSE](http://github.com/LeventErkok/sbv/tree/master/LICENSE) file contains
the [BSD3](http://en.wikipedia.org/wiki/BSD_licenses) verbiage.

Thanks
======
The following people reported bugs, provided comments/feedback, or contributed to the development of SBV in various ways:
Ian Blumenfeld, Ian Calvert, Iavor Diatchki, John Erickson, Tom Hawkins, Lee Pike, Austin Seipp, Don Stewart, Josef Svenningsson,
and Nis Wegmann.
