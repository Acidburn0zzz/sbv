-----------------------------------------------------------------------------
-- |
-- Module      :  Data.SBV.BitVectors.GenTest
-- Copyright   :  (c) Levent Erkok
-- License     :  BSD3
-- Maintainer  :  erkokl@gmail.com
-- Stability   :  experimental
-- Portability :  portable
--
-- Test generation from symbolic programs
-----------------------------------------------------------------------------

module Data.SBV.BitVectors.GenTest (genTest, renderTest) where

import Data.Maybe    (fromMaybe)
import Data.List     (intercalate, groupBy)
import System.Random

import Data.SBV.BitVectors.Data
import Data.SBV.BitVectors.PrettyNum

-- | Generate a set of concrete test values from a symbolic program. The output
-- can be rendered as test vectors in different languages as necessary. Use the
-- function 'output' call to indicate what fields should be in the test result.
-- (Also see 'constrain' and 'pConstrain' for filtering acceptable test values.)
genTest :: Outputtable a => Int -> Symbolic a -> IO [([CW], [CW])]
genTest n m = gen 0 []
  where gen i sofar
         | i == n = return $ reverse sofar
         | True   = do g <- newStdGen
                       t <- tc g
                       gen (i+1) (t:sofar)
        tc g = do (_, Result _ tvals _ _ cs _ _ _ _ _ cstrs os) <- runSymbolic' (Concrete g) (m >>= output)
                  let cval = fromMaybe (error "Cannot generate tests in the presence of uninterpeted constants!") . (`lookup` cs)
                      cond = all (cwToBool . cval) cstrs
                  if cond
                     then return (map snd tvals, map cval os)
                     else tc g  -- try again, with the same set of constraints

-- | Render the test as a Haskell value with the given name @n@.
renderTest :: String -> [([CW], [CW])] -> String
renderTest n vs = intercalate "\n" $ [ "-- Automatically generated by SBV. Do not edit!"
                                     , n ++ " :: " ++ getType vs
                                     , n ++ " = [ " ++ intercalate ("\n" ++ pad ++  ", ") (map mkLine vs), pad ++ "]"
                                     ]
  where pad = replicate (length n + 3) ' '
        getType []         = "[a]"
        getType ((i, o):_) = "[(" ++ mapType typeOf i ++ ", " ++ mapType typeOf o ++ ")]"
        mkLine  (i, o)     = "("  ++ mapType valOf  i ++ ", " ++ mapType valOf  o ++ ")"
        mapType f cws = mkTuple $ map f $ groupBy (\c1 c2 -> (cwSigned c1, cwSize c1) == (cwSigned c2, cwSize c2)) cws
        mkTuple [x] = x
        mkTuple xs  = "(" ++ intercalate ", " xs ++ ")"
        typeOf []    = "()"
        typeOf [x]   = t x
        typeOf (x:_) = "[" ++ t x ++ "]"
        valOf  []    = "()"
        valOf  [x]   = s x
        valOf  xs    = "[" ++ intercalate ", " (map s xs) ++ "]"
        t cw = case (cwSigned cw, cwSize cw) of
                  (False, Size (Just  1)) -> "Bool"
                  (False, Size (Just  8)) -> "Word8"
                  (False, Size (Just 16)) -> "Word16"
                  (False, Size (Just 32)) -> "Word32"
                  (False, Size (Just 64)) -> "Word64"
                  (True,  Size (Just  8)) -> "Int8"
                  (True,  Size (Just 16)) -> "Int16"
                  (True,  Size (Just 32)) -> "Int32"
                  (True,  Size (Just 64)) -> "Int64"
                  (True,  Size (Nothing)) -> "Integer"
                  _                -> error $ "SBV.renderTest: Unexpected CW: " ++ show cw
        s cw = case (cwSigned cw, cwSize cw) of
                  (False, Size (Just 1)) -> show (cwToBool cw)
                  (sgn, Size (Just sz))  -> shex  False True (sgn, sz) (cwVal cw)
                  (_,   Size Nothing)    -> shexI False True           (cwVal cw)
