-----------------------------------------------------------------------------
-- |
-- Module      :  Data.SBV.BitVectors.GenTest
-- Copyright   :  (c) Levent Erkok
-- License     :  BSD3
-- Maintainer  :  erkokl@gmail.com
-- Stability   :  experimental
-- Portability :  portable
--
-- Test generation from symbolic programs
-----------------------------------------------------------------------------

module Data.SBV.BitVectors.GenTest (genTest, TestVectors, getTestValues, renderTest, TestStyle(..)) where

import Data.Maybe    (fromMaybe)
import Data.List     (intercalate, groupBy)
import System.Random

import Data.SBV.BitVectors.Data
import Data.SBV.BitVectors.PrettyNum

-- | Type of test vectors (abstract)
newtype TestVectors = TV [([CW], [CW])]

-- | Retrieve the test vectors for further processing. This function
-- is useful in cases where 'renderTest' is not sufficient and custom
-- output (or further preprocessing) is needed.
getTestValues :: TestVectors -> [([CW], [CW])]
getTestValues (TV vs) = vs

-- | Generate a set of concrete test values from a symbolic program. The output
-- can be rendered as test vectors in different languages as necessary. Use the
-- function 'output' call to indicate what fields should be in the test result.
-- (Also see 'constrain' and 'pConstrain' for filtering acceptable test values.)
genTest :: Outputtable a => Int -> Symbolic a -> IO TestVectors
genTest n m = gen 0 []
  where gen i sofar
         | i == n = return $ TV $ reverse sofar
         | True   = do g <- newStdGen
                       t <- tc g
                       gen (i+1) (t:sofar)
        tc g = do (_, Result _ tvals _ _ cs _ _ _ _ _ cstrs os) <- runSymbolic' (Concrete g) (m >>= output)
                  let cval = fromMaybe (error "Cannot generate tests in the presence of uninterpeted constants!") . (`lookup` cs)
                      cond = all (cwToBool . cval) cstrs
                  if cond
                     then return (map snd tvals, map cval os)
                     else tc g  -- try again, with the same set of constraints

-- | Test output style
data TestStyle = Haskell String   -- ^ As a Haskell value with given name
               | C       String   -- ^ As a C array of structs with given name

-- | Render the test as a Haskell value with the given name @n@.
renderTest :: TestStyle -> TestVectors -> String
renderTest (Haskell n) (TV vs) = haskell n vs
renderTest (C n)       (TV vs) = c       n vs

haskell :: String -> [([CW], [CW])] -> String
haskell n vs = intercalate "\n" [ "-- Automatically generated by SBV. Do not edit!"
                                   , n ++ " :: " ++ getType vs
                                   , n ++ " = [ " ++ intercalate ("\n" ++ pad ++  ", ") (map mkLine vs), pad ++ "]"
                                   ]
  where pad = replicate (length n + 3) ' '
        getType []         = "[a]"
        getType ((i, o):_) = "[(" ++ mapType typeOf i ++ ", " ++ mapType typeOf o ++ ")]"
        mkLine  (i, o)     = "("  ++ mapType valOf  i ++ ", " ++ mapType valOf  o ++ ")"
        mapType f cws = mkTuple $ map f $ groupBy (\c1 c2 -> (cwSigned c1, cwSize c1) == (cwSigned c2, cwSize c2)) cws
        mkTuple [x] = x
        mkTuple xs  = "(" ++ intercalate ", " xs ++ ")"
        typeOf []    = "()"
        typeOf [x]   = t x
        typeOf (x:_) = "[" ++ t x ++ "]"
        valOf  []    = "()"
        valOf  [x]   = s x
        valOf  xs    = "[" ++ intercalate ", " (map s xs) ++ "]"
        t cw = case (cwSigned cw, cwSize cw) of
                  (False, Size (Just  1)) -> "Bool"
                  (False, Size (Just  8)) -> "Word8"
                  (False, Size (Just 16)) -> "Word16"
                  (False, Size (Just 32)) -> "Word32"
                  (False, Size (Just 64)) -> "Word64"
                  (True,  Size (Just  8)) -> "Int8"
                  (True,  Size (Just 16)) -> "Int16"
                  (True,  Size (Just 32)) -> "Int32"
                  (True,  Size (Just 64)) -> "Int64"
                  (True,  Size Nothing)   -> "Integer"
                  _                       -> error $ "SBV.renderTest: Unexpected CW: " ++ show cw
        s cw = case (cwSigned cw, cwSize cw) of
                  (False, Size (Just 1)) -> show (cwToBool cw)
                  (sgn, Size (Just sz))  -> shex  False True (sgn, sz) (cwVal cw)
                  (_,   Size Nothing)    -> shexI False True           (cwVal cw)

c :: String -> [([CW], [CW])] -> String
c _n _vs = error "test.c: TBD"
{-

#include <stdio.h>

typedef struct {
   struct {
      int i0;
      int i1;
   } input;
   struct {
      int o0;
      int o1;
   } output;
} fooTestVector;

fooTestVector foo[] = {
   {{2, 3}, {4, 5}}
 , {{6, 7}, {8, 9}}
 };

int fooLength = 2;

int main(void)
{
  int i;
  for(i = 0; i < fooLength; ++i)
  {
    printf("%d, %d -> %d, %d\n", foo[i].input.i0, foo[i].input.i1, foo[i].output.o0, foo[i].output.o1);
  }
  return 0;
}

-}
